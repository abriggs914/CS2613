#lang racket

(define (drop-divisible i lst)
  (if (empty? lst)
      empty
      (if (or (< (first lst) (+ i 1)) (not (equal? (modulo (first lst) i) 0)))
          (cons (first lst) (drop-divisible i (rest lst)))
      (drop-divisible i (rest lst)))))

(module+ test
  (require rackunit)
  (check-equal? (drop-divisible 3 (list 2 3 4 5 6 7 8 9 10)) (list 2 3 4 5 7 8 10)))

(drop-divisible 3 '(5 9 14 11 12 13 24 36 5 6 9 36 10 11))

(map (lambda (number) (+ 1 number)) '(1 2 3 4))

(define (sieve-with div lst)
  (map (lambda (div) (drop-divisible div lst)) div))

(sieve-with '(2 3 5) (list 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))

(module+ test
  (check-equal? (sieve-with '(2 3) (list 2 3 4 5 6 7 8 9 10)) (list 2 3 5 7)))

